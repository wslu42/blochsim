<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bloch Sphere Simulator</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- MathJax CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls for camera control -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a1a1a;
            color: #e5e7eb;
            user-select: none;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .container {
            display: flex;
            flex-direction: column;
            gap: 2rem;
            padding: 2rem;
            background-color: #2c2c2c;
            border-radius: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 10px 20px rgba(0, 0, 0, 0.2);
            max-width: 1200px;
            width: 90%;
            margin: 2rem auto;
        }

        .canvas-container {
            width: 100%;
            max-width: 600px;
            aspect-ratio: 1 / 1;
            border-radius: 1rem;
            overflow: hidden;
            background-color: #2c2c2c;
            position: relative;
        }
        
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(44, 44, 44, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .info-panel {
            background-color: #1a1a1a;
            padding: 1.5rem;
            border-radius: 0.75rem;
            font-size: 0.875rem;
            white-space: pre-wrap;
            line-height: 1.5;
        }

        .buttons-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .gate-button {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            background-color: #4a4a4a;
            color: #fff;
            font-weight: 600;
            transition: all 0.2s;
        }

        .gate-button:hover {
            background-color: #5a5a5a;
            transform: translateY(-2px);
        }

        .gate-button:active {
            background-color: #3a3a3a;
            transform: translateY(0);
        }

        .phase-gate-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 p-8 flex flex-col items-center justify-center">

    <div class="container lg:flex-row items-center">
        <div class="sidebar flex-1 w-full lg:w-auto">
            <h1 class="text-3xl font-bold text-center lg:text-left mb-2">Bloch Sphere Simulator</h1>
            <div class="info-panel text-sm text-gray-400">
                <p>original code owner: <b>Hong-Yi Yang</b>. Master Student at NCHU, Taiwan</p>
                <p>adopted and modified by Wen-Sen Lu, IBM Quantum</p>
                <p class="mt-4 font-bold text-gray-300">Manual:</p>
                <p>Drag with right click: rotate; Scroll: zoom; Left click + Shift: pan</p>
                <p>使用說明: 滑鼠右鍵: 旋轉視角; 滾輪: 縮放畫面; 左鍵+Shift: 平移</p>
            </div>
            <div class="info-panel text-gray-300" id="state-display">
                <!-- VPython code seems to use MathJax on the fly. We'll set the initial state here. -->
                $$\vert \Psi \rangle =\alpha \vert 0\rangle +\beta \vert 1\rangle$$
                $$\alpha =\cos \frac{\theta }{2}\text{  ;  }\beta =e^{i\phi }\sin \frac{\theta }{2}$$
                <br>
                <span id="qubit-state">
                    $\theta = 0^{\circ}$ ; $\phi = 0^{\circ}$<br>
                    $\alpha = 1$ ; $\beta = 0 + 0i$<br>
                    Probability of $\vert 0\rangle$: 100.00%<br>
                    Probability of $\vert 1\rangle$: 0.00%
                </span>
            </div>
            <div class="buttons-container">
                <button id="init-button" class="gate-button">qubit init.</button>
                <button id="h-gate-button" class="gate-button">H gate</button>
                <button id="x-gate-button" class="gate-button">X gate</button>
                <button id="y-gate-button" class="gate-button">Y gate</button>
                <button id="z-gate-button" class="gate-button">Z gate</button>
                <button id="s-gate-button" class="gate-button">S gate</button>
                <button id="t-gate-button" class="gate-button">T gate</button>
                <div class="phase-gate-container">
                    <input type="number" id="phase-input" value="90" class="w-16 px-2 py-1 rounded-md bg-gray-700 text-white">
                    <button id="phase-gate-button" class="gate-button">phase gate</button>
                </div>
            </div>
        </div>

        <div class="canvas-container shadow-2xl">
            <div id="loading-overlay" class="loading-overlay">
                <div class="spinner"></div>
            </div>
            <canvas id="bloch-sphere-canvas"></canvas>
        </div>
    </div>

    <script>
        // Check for WebGL compatibility
        if (THREE.WebGLRenderer === undefined) {
            document.getElementById('loading-overlay').innerHTML = "Your browser does not support WebGL.";
        }

        document.addEventListener('DOMContentLoaded', () => {
            const loadingOverlay = document.getElementById('loading-overlay');
            const canvasContainer = document.getElementById('bloch-sphere-canvas');
            const stateDisplay = document.getElementById('qubit-state');
            const phaseInput = document.getElementById('phase-input');
            const labelContainer = document.getElementById('bloch-sphere-canvas').parentNode;

            let scene, camera, renderer, controls;
            let pointer; // The Bloch vector
            let isAnimating = false;
            let currentAnimation = null;
            let animationStep = 0;
            const animationStepsTotal = 90; // for H, X, Y, Z gates
            const animationStepsS = 90; // for S gate (pi/2 rotation)
            const animationStepsT = 90; // for T gate (pi/4 rotation)

            // Setup
            function init() {
                // Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x2c2c2c);

                // Camera
                camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
                // 調整攝影機位置，從 (0, -3, 0) 改為 (-3, 0, 0)
                // 這樣 +z 軸會朝上，+y 軸朝右，提供更直觀的視角
                camera.position.set(2, 2, 2);
                camera.lookAt(0, 0, 0);

                // Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true, canvas: canvasContainer });
                renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                window.addEventListener('resize', onWindowResize, false);





                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 5, 5);
                scene.add(directionalLight);

                // Controls
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.minDistance = 1.5;
                controls.maxDistance = 6;
                controls.enablePan = true;
                
                // Set initial camera position similar to VPython
                controls.target.set(0, 0, 0); // Center the view
                controls.update();

                // 移除對整個場景的旋轉，避免與 'qubit init.' 按鈕產生衝突
                const rotationAxis = new THREE.Vector3(-1, -1, -1).normalize();
                const rotationAngle = Math.PI / 3 * 2; // 120 degrees in radians
                const quaternion = new THREE.Quaternion().setFromAxisAngle(rotationAxis, rotationAngle);
                scene.quaternion.multiplyQuaternions(quaternion, scene.quaternion);
                
                // Hide loading overlay
                loadingOverlay.style.display = 'none';

                // Create Bloch Sphere and Axes
                createBlochSphere();
                createAxesAndLabels();

                // Create the qubit state vector
                pointer = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0), 1, 0x8040ff, 0.1, 0.1);
                scene.add(pointer);

                updateStateDisplay();
                animate();
            }

            function onWindowResize() {
                const parent = canvasContainer.parentNode;
                const width = parent.clientWidth;
                const height = parent.clientHeight;
                renderer.setSize(width, height);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                controls.update();
            }

            function createBlochSphere() {
                const geometry = new THREE.SphereGeometry(1, 64, 32);
                const material = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, transparent: true, opacity: 0.12, roughness: 0.5 });
                const sphere = new THREE.Mesh(geometry, material);
                scene.add(sphere);
            }

            function createAxesAndLabels() {
                const axisLength = 1.25;
                const axisColor = 0x4a4a4a;

                // X Axis
                const xAxis = new THREE.ArrowHelper(new THREE.Vector3(-axisLength, 0, 0), new THREE.Vector3(1, 0, 0), 2 * axisLength, axisColor, 0.05, 0.05);
                scene.add(xAxis);

                // Y Axis
                const yAxis = new THREE.ArrowHelper(new THREE.Vector3(0, -axisLength, 0), new THREE.Vector3(0, 1, 0), 2 * axisLength, axisColor, 0.05, 0.05);
                scene.add(yAxis);

                // Z Axis
                const zAxis = new THREE.ArrowHelper(new THREE.Vector3(0, 0, -axisLength), new THREE.Vector3(0, 0, 1), 2 * axisLength, axisColor, 0.05, 0.05);
                scene.add(zAxis);

                // Add labels for basis states and axes
                addLabel('x', new THREE.Vector3(axisLength * 1.05, 0, 0));
                addLabel('y', new THREE.Vector3(0, axisLength * 1.05, 0));
                addLabel('z', new THREE.Vector3(0, 0, axisLength * 1.05));
            }

            function addLabel(text, position) {
                const element = document.createElement('div');
                element.className = 'absolute text-gray-400 text-sm';
                // 使用 transform 將元素中心點設為其自身中心，方便精確定位
                element.style.transform = 'translate(-50%, -50%)';
                element.innerHTML = text;
                // 將標籤添加到 canvas 的父容器中，使其位置相對於該容器
                labelContainer.appendChild(element);

                const vector = new THREE.Vector3(position.x, position.y, position.z);
                element.style.position = 'absolute';

                function updatePosition() {
                    const tempV = vector.clone();
                    // 在投影到螢幕座標之前，將場景的旋轉應用到標籤向量上，
                    // 確保標籤能跟著場景一起旋轉。
                    tempV.applyQuaternion(scene.quaternion);

                    // 將 3D 位置投影到 2D 螢幕座標
                    tempV.project(camera);
                    
                    const containerRect = labelContainer.getBoundingClientRect();

                    // 根據投影的座標和容器大小計算像素位置
                    element.style.left = ((tempV.x + 1) / 2 * containerRect.width) + 'px';
                    element.style.top = ((-tempV.y + 1) / 2 * containerRect.height) + 'px';
                }
                updatePosition();
                controls.addEventListener('change', updatePosition);
            }

            function animate() {
                requestAnimationFrame(animate);

                if (isAnimating) {
                    currentAnimation();
                }

                controls.update();
                renderer.render(scene, camera);
            }

            // --- State and Calculation Functions ---

            function fround(vector) {
                const threshold = 1e-5;
                return {
                    x: Math.abs(vector.x) < threshold ? 0 : (Math.abs(vector.x - 1) < threshold ? 1 : (Math.abs(vector.x + 1) < threshold ? -1 : vector.x)),
                    y: Math.abs(vector.y) < threshold ? 0 : (Math.abs(vector.y - 1) < threshold ? 1 : (Math.abs(vector.y + 1) < threshold ? -1 : vector.y)),
                    z: Math.abs(vector.z) < threshold ? 0 : (Math.abs(vector.z - 1) < threshold ? 1 : (Math.abs(vector.z + 1) < threshold ? -1 : vector.z))
                };
            }

            function updateStateDisplay() {
                const currentAxis = pointer.quaternion.multiplyVector3(new THREE.Vector3(0, 0, 1)).normalize();
                const { x, y, z } = fround(currentAxis);

                const theta = Math.acos(z);
                const phi = Math.atan2(y, x);

                const alpha = Math.cos(theta / 2);
                const beta_re = Math.cos(phi) * Math.sin(theta / 2);
                const beta_im = Math.sin(phi) * Math.sin(theta / 2);
                
                const prob0 = Math.pow(alpha, 2) * 100;
                const prob1 = (Math.pow(beta_re, 2) + Math.pow(beta_im, 2)) * 100;

                const textContent = `
                    $$\\theta = ${Math.round(theta * 180 / Math.PI)}^{\\circ}$$ ; $$\\phi = ${Math.round(phi * 180 / Math.PI)}^{\\circ}$$<br>
                    $$\\alpha = ${alpha.toFixed(3)}$$ ; $$\\beta = ${beta_re.toFixed(3)} + ${beta_im.toFixed(3)}i$$<br>
                    Probability of $|0\\rangle$: ${prob0.toFixed(2)}%<br>
                    Probability of $|1\\rangle$: ${prob1.toFixed(2)}%
                `;

                stateDisplay.innerHTML = textContent;
                MathJax.typesetPromise([stateDisplay]).catch((err) => console.log('MathJax typeset error:', err));
            }

            // --- Gate Animations ---

            function startAnimation(animationFunction) {
                if (isAnimating) return;
                isAnimating = true;
                animationStep = 0;
                currentAnimation = animationFunction;
            }

            function hGateAnimation() {
                const rotAxis = new THREE.Vector3(1, 0, 1).normalize();
                const rotAngle = Math.PI / animationStepsTotal;
                const rotationQuaternion = new THREE.Quaternion().setFromAxisAngle(rotAxis, rotAngle);
                pointer.quaternion.multiply(rotationQuaternion);
                animationStep++;
                if (animationStep >= animationStepsTotal) {
                    isAnimating = false;
                    updateStateDisplay();
                }
            }
            
            function xGateAnimation() {
                const rotAxis = new THREE.Vector3(1, 0, 0);
                const rotAngle = Math.PI / animationStepsTotal;
                const rotationQuaternion = new THREE.Quaternion().setFromAxisAngle(rotAxis, rotAngle);
                pointer.quaternion.multiply(rotationQuaternion);
                animationStep++;
                if (animationStep >= animationStepsTotal) {
                    isAnimating = false;
                    updateStateDisplay();
                }
            }

            function yGateAnimation() {
                const rotAxis = new THREE.Vector3(0, 1, 0); // Correct rotation axis for Y gate
                const rotAngle = Math.PI / animationStepsTotal;
                const rotationQuaternion = new THREE.Quaternion().setFromAxisAngle(rotAxis, rotAngle);
                pointer.quaternion.multiply(rotationQuaternion);
                animationStep++;
                if (animationStep >= animationStepsTotal) {
                    isAnimating = false;
                    updateStateDisplay();
                }
            }
            
            function zGateAnimation() {
                const rotAxis = new THREE.Vector3(0, 0, 1); // Correct rotation axis for Z gate
                const rotAngle = Math.PI / animationStepsTotal;
                const rotationQuaternion = new THREE.Quaternion().setFromAxisAngle(rotAxis, rotAngle);
                pointer.quaternion.multiply(rotationQuaternion);
                animationStep++;
                if (animationStep >= animationStepsTotal) {
                    isAnimating = false;
                    updateStateDisplay();
                }
            }
            
            function sGateAnimation() {
                const rotAxis = new THREE.Vector3(0, 0, 1);
                const rotAngle = Math.PI / 2 / animationStepsS;
                const rotationQuaternion = new THREE.Quaternion().setFromAxisAngle(rotAxis, rotAngle);
                pointer.quaternion.multiply(rotationQuaternion);
                animationStep++;
                if (animationStep >= animationStepsS) {
                    isAnimating = false;
                    updateStateDisplay();
                }
            }

            function tGateAnimation() {
                const rotAxis = new THREE.Vector3(0, 0, 1);
                const rotAngle = Math.PI / 4 / animationStepsT;
                const rotationQuaternion = new THREE.Quaternion().setFromAxisAngle(rotAxis, rotAngle);
                pointer.quaternion.multiply(rotationQuaternion);
                animationStep++;
                if (animationStep >= animationStepsT) {
                    isAnimating = false;
                    updateStateDisplay();
                }
            }

            function phaseGateAnimation() {
                const inputPhase = parseFloat(phaseInput.value);
                if (isNaN(inputPhase) || isAnimating) return;

                const rotAxis = new THREE.Vector3(0, 0, 1);
                const rotAngle = (inputPhase * Math.PI / 180) / animationStepsTotal;
                const rotationQuaternion = new THREE.Quaternion().setFromAxisAngle(rotAxis, rotAngle);
                
                const phaseAnimation = () => {
                    pointer.quaternion.multiply(rotationQuaternion);
                    animationStep++;
                    if (animationStep >= animationStepsTotal) {
                        isAnimating = false;
                        updateStateDisplay();
                    }
                };
                startAnimation(phaseAnimation);
            }

            // --- UI Event Listeners ---

            document.getElementById('init-button').addEventListener('click', () => {
                if (isAnimating) return;
                // 使用 setDirection 確保箭頭的**方向**直接被設定為 +z 軸
                pointer.setDirection(new THREE.Vector3(0, 0, 1));
                updateStateDisplay();
            });
            document.getElementById('h-gate-button').addEventListener('click', () => startAnimation(hGateAnimation));
            document.getElementById('x-gate-button').addEventListener('click', () => startAnimation(xGateAnimation));
            document.getElementById('y-gate-button').addEventListener('click', () => startAnimation(yGateAnimation));
            document.getElementById('z-gate-button').addEventListener('click', () => startAnimation(zGateAnimation));
            document.getElementById('s-gate-button').addEventListener('click', () => startAnimation(sGateAnimation));
            document.getElementById('t-gate-button').addEventListener('click', () => startAnimation(tGateAnimation));
            document.getElementById('phase-gate-button').addEventListener('click', phaseGateAnimation);

            // Start the application
            init();
        });
    </script>
</body>
</html>
