<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bloch Sphere — Vanilla JS（非模組、內建滑鼠控制）</title>
  <script src="https://unpkg.com/three@0.148.0/build/three.min.js"></script>
  <script>
    window.MathJax = { tex: { inlineMath: [["$","$"],["\\(","\\)"]] } };
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    html, body { margin:0; height:100%; font-family: ui-sans-serif, system-ui; }
    #app { display:flex; gap:12px; height:100%; }
    #left { width:420px; min-width:320px; box-sizing:border-box; padding:12px 14px; border-right:1px solid #e5e7eb; overflow:auto; }
    #title { font-weight:700; margin-bottom:6px; }
    #owner { font-size:12px; color:#6b7280; line-height:1.4; }
    #controls { display:flex; flex-wrap:wrap; gap:8px; margin:10px 0 12px; }
    button, input[type="number"] { padding:8px 10px; border:1px solid #d1d5db; border-radius:10px; background:#fff; cursor:pointer; font-weight:600; }
    #canvasWrap { position:relative; flex:0 0 520px; width:520px; height:520px; border:1px solid #e5e7eb; background:#f7fafc; }
    #caption { white-space:pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:13px; }
  </style>
</head>
<body>
<div id="app">
  <div id="canvasWrap"></div>

  <div id="left">
    <div id="title">Bloch Sphere</div>
    <div id="owner">original code owner: <b>Hong‑Yi Yang</b> (NCHU, Taiwan)<br>adopted & modified for vanilla JS by Wen‑Sen</div>
    <div>Manual — 左鍵拖曳: 旋轉、滾輪: 縮放、右鍵拖曳: 平移</div>

    <div id="equations">
      $|\\Psi\\rangle = \\alpha |0\\rangle + \\beta |1\\rangle$ ; $\\alpha=\\cos\\tfrac{\\theta}{2}$ ; $\\beta=e^{i\\phi}\\sin\\tfrac{\\theta}{2}$
    </div>

    <div id="controls">
      <button id="initBtn">qubit init.</button>
      <button id="HBtn">H gate</button>
      <button id="XBtn">X gate</button>
      <button id="YBtn">Y gate</button>
      <button id="ZBtn">Z gate</button>
    </div>

    <div id="caption"></div>
  </div>
</div>

<script>
  const scale = 1.25;
  const wrap = document.getElementById('canvasWrap');
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf7fafc);

  const camera = new THREE.PerspectiveCamera(35, (wrap.clientWidth||520)/(wrap.clientHeight||520), 0.1, 100);
  const target = new THREE.Vector3(0,0,0);
  let radius = 3.8, theta = Math.PI/4, phi = Math.PI/3;
  function updateCamera(){
    const x = target.x + radius * Math.sin(phi) * Math.sin(theta);
    const y = target.y + radius * Math.cos(phi);
    const z = target.z + radius * Math.sin(phi) * Math.cos(theta);
    camera.position.set(x,y,z);
    camera.lookAt(target);
  }
  updateCamera();

  const renderer = new THREE.WebGLRenderer({ antialias:true });
  const w0 = wrap.clientWidth||520, h0 = wrap.clientHeight||520;
  renderer.setPixelRatio(window.devicePixelRatio||1);
  renderer.setSize(w0,h0);
  wrap.appendChild(renderer.domElement);

  scene.add(new THREE.AmbientLight(0xffffff, 0.9));
  scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.4));

  const ball = new THREE.Mesh(
    new THREE.SphereGeometry(0.9*scale, 32, 16),
    new THREE.MeshBasicMaterial({ color:0x888888, wireframe:true })
  );
  scene.add(ball);

  const axisMat = new THREE.LineBasicMaterial({ color:0x6b7280, transparent:true, opacity:0.35 });
  function axis(from, to){
    const g = new THREE.BufferGeometry().setFromPoints([from,to]);
    scene.add(new THREE.Line(g, axisMat));
  }
  axis(new THREE.Vector3(-scale,0,0), new THREE.Vector3(scale,0,0));
  axis(new THREE.Vector3(0,-scale,0), new THREE.Vector3(0,scale,0));
  axis(new THREE.Vector3(0,0,-scale), new THREE.Vector3(0,0,scale));

  // 使用 Vector3 追蹤箭頭方向，避免 ArrowHelper 缺少 getDirection
  let pointerDir = new THREE.Vector3(0,0,1);
  const pointer = new THREE.ArrowHelper(pointerDir.clone().normalize(), new THREE.Vector3(0,0,0), 0.95*scale, 0x9333ea);
  scene.add(pointer);
  function setPointerDir(v){ pointerDir.copy(v.clone().normalize()); pointer.setDirection(pointerDir); }
  function initQ(){ setPointerDir(new THREE.Vector3(0,0,1)); }
  document.getElementById('initBtn').onclick = initQ; initQ();

  let dragging = false; let panMode = false; let lastX=0, lastY=0;
  const ROT_SPEED = 0.005, PAN_SPEED = 0.002, ZOOM_SPEED = 0.001;

  renderer.domElement.addEventListener('contextmenu', e=>e.preventDefault());
  renderer.domElement.addEventListener('mousedown', e=>{
    dragging = true; lastX=e.clientX; lastY=e.clientY; panMode = (e.button===2);
  });
  window.addEventListener('mouseup', ()=>dragging=false);
  window.addEventListener('mousemove', e=>{
    if(!dragging) return;
    const dx = e.clientX - lastX; const dy = e.clientY - lastY; lastX=e.clientX; lastY=e.clientY;
    if(!panMode){
      theta -= dx * ROT_SPEED;
      phi   -= dy * ROT_SPEED;
      const EPS=1e-3; phi = Math.max(EPS, Math.min(Math.PI-EPS, phi));
      updateCamera();
    }else{
      const dir = new THREE.Vector3(); camera.getWorldDirection(dir).normalize();
      const right = new THREE.Vector3().crossVectors(dir, camera.up).normalize();
      const upv = new THREE.Vector3().crossVectors(right, dir).normalize();
      const move = new THREE.Vector3().addScaledVector(right, -dx*PAN_SPEED*radius)
                                     .addScaledVector(upv,   dy*PAN_SPEED*radius);
      target.add(move); updateCamera();
    }
  });
  renderer.domElement.addEventListener('wheel', e=>{
    e.preventDefault();
    radius *= (1 + e.deltaY * ZOOM_SPEED); radius = Math.max(1.2, Math.min(20, radius));
    updateCamera();
  }, { passive:false });

  function animateRotation(axis, totalDeg){
    let steps = 60; let step = THREE.MathUtils.degToRad(totalDeg/steps); let frame=0;
    (function stepAnim(){
      if(frame>=steps) return; requestAnimationFrame(stepAnim);
      pointerDir.applyAxisAngle(axis, step);
      setPointerDir(pointerDir);
      frame++;
    })();
  }
  document.getElementById('HBtn').onclick = ()=>animateRotation(new THREE.Vector3(1,0,1).normalize(),180);
  document.getElementById('XBtn').onclick = ()=>animateRotation(new THREE.Vector3(1,0,0),180);
  document.getElementById('YBtn').onclick = ()=>animateRotation(new THREE.Vector3(0,1,0),180);
  document.getElementById('ZBtn').onclick = ()=>animateRotation(new THREE.Vector3(0,0,1),180);

  (function render(){ requestAnimationFrame(render); renderer.render(scene, camera); })();
</script>
</body>
</html>
